- AFTER FIXING TEXTURES, READ BEST PRACTICES AND WRITE NOTES!
- Also try tools like RMV

- Automatic subresource format tracking. If resource A gets copied into resource B, and it's known that resource B has format F, then resource A should also have format F.
- CMake
- Blit pass
- More fine-grained barriers (no TOP_OF_PIPE/BOTTOM_OF_PIPE)
- Async compute: cross-queue barriers
- Scene subobjects
- String views and vector ranges
- Dedicated allocation (VkMemoryDedicatedRequirements::prefersDedicatedAllocation)
- Try to compress vertices and compare compressed + uncompressed performance.
- Depth prepass
- BATCH pipeline creation calls (maybe something like pipeline allocator will help? Instead of calling vkCreateGraphicsPipelines, schedule it to creation in allocator)
- Pipeline cache (allocator again)
- Fences after transit in frame graph and scene builders
- Try to do VERTEX PULLING
- Uint16 or Uint32 indices?
- Separate descriptor sets
- INSTANCING
- VulkanSH.h Ð¸ VulkanSH.cpp
- Compare HOST_VISIBLE-only memory with cached DEVICE_LOCAL copy (yes, it influences descriptor sets too!)
- Anisotropic filtering
- CHECK GAMMA CORRECTION
- Object data updating: memcpy() data for eah object or batch updates for sequentional objects (harder because of alignment)
- VECTORCALL functions in user code
- Scene controls abstraction: the perfect way would be to use a class that has std::function bound to each user input event. This way Scene could use it instead of ugly member functions to control camera.
- More on input: it should be handled by a finite state machine. This finite state machine should be outside of input class (because input class doesn't know about states)
- Reverse depth
- Profile cache usage
- #include <system_error>
- Allocators
- Camera component?

- DX12: Dedicated present queue is good (https://gpuopen.com/performance/)
- DX12: Use DXC with /Zpr option