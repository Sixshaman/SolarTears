- AFTER FIXING TEXTURES, READ BEST PRACTICES AND WRITE NOTES!
- Also try tools like RMV. And turns out NSight has A LOT of interesting profiling tools, including memory workload analysis!

- Correct event driven controls: all movements and stuff should be updated constantly and be equal some value once a key pressed and equal 0 when released.
- Automatic subresource format tracking. If resource A gets copied into resource B, and it's known that resource B has format F, then resource A should also have format F.
- CMake
- OWNDC
- Thread-related stuff (including command buffers, dependency levels, etc.) should be spaced far away to avoid false cache sharing
- Revise scene world structure - maybe do principal XYZ axes instead of scale+rotation+translation? Google it
- Right-handed instead of left-handed
- Blit pass
- More fine-grained barriers (no TOP_OF_PIPE/BOTTOM_OF_PIPE)
- Async compute: Async compute passes should be in the end of the frame. BUT! They should be executed AT THE START of THE PREVIOUS frame. Need to reorder stuff for that
- Some sort of extension picker for Vulkan?
- Async compute: cross-queue barriers
- Scene subobjects
- String views and vector ranges
- Dedicated allocation (VkMemoryDedicatedRequirements::prefersDedicatedAllocation)
- Try to compress vertices and compare compressed + uncompressed performance.
- Depth prepass
- Render scale parameter in each buffer of the frame graph
- BATCH pipeline creation calls (maybe something like pipeline allocator will help? Instead of calling vkCreateGraphicsPipelines, schedule it to creation in allocator)
- Pipeline cache (allocator again)
- Fences after transit in frame graph and scene builders
- Try to do VERTEX PULLING
- Uint16 or Uint32 indices?
- Infinite projection matrices with reversed depth
- Separate descriptor sets
- INSTANCING
- Real HDR
- Use std::string_view in most places of frame graph builder
- VulkanSH.h Ð¸ VulkanSH.cpp
- Compare HOST_VISIBLE-only memory with cached DEVICE_LOCAL copy (yes, it influences descriptor sets too!)
- Anisotropic filtering
- CHECK GAMMA CORRECTION
- std::hardware_destructive_interference_size and std::hardware_constructive_interference_size 
- Object data updating: memcpy() data for eah object or batch updates for sequentional objects (harder because of alignment)
- VECTORCALL functions in user code
- Scene controls abstraction: the perfect way would be to use a class that has std::function bound to each user input event. This way Scene could use it instead of ugly member functions to control camera.
- More on input: it should be handled by a finite state machine. This finite state machine should be outside of input class (because input class doesn't know about states)
- Different allocation and management for static and dynamic buffers and textures
- Reverse depth
- Profile cache usage
- #include <system_error>
- Allocators
- Separate render pass allocators
- Camera component?
- Fullscreen

- DX12: Dedicated present queue is good (https://gpuopen.com/performance/)
- DX12: Use DXC with /Zpr option
- DX12: DXGI_SWAP_CHAIN_FLAG_ALLOW_TEARING
- DX12: GBV